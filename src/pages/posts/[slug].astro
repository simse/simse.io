---
import { getCollection } from "astro:content";
import type { CollectionEntry } from "astro:content";
import BaseLayout from "@/layouts/base.astro";
import Navbar from "@/components/Navbar.astro";
import Footer from "@/components/Footer.astro";
import TableOfContents from "@/components/blog/TableOfContents.astro";
import Tag from "@/components/blog/Tag.astro";
import { Image } from 'astro:assets';
import BlogPostCard from "@/components/blog/BlogPostCard.astro";

export async function getStaticPaths() {
  let blogEntries = await getCollection("blog");

  // filter out drafts
  if (import.meta.env.PROD) {
    blogEntries = blogEntries.filter((entry) => !entry.data.draft);
  }

  return blogEntries.map((entry) => ({
    params: { slug: entry.slug },
    props: { entry },
  }));
}

interface Props {
  entry: CollectionEntry<"blog">;
}

const { entry } = Astro.props;
const { Content, headings } = await entry.render();

const imageHeight: {
  [key: string]: string;
} = {
  third: "h-[33vh]",
  half: "h-[50vh]",
  fullscreen: "h-[100vh]",
  "below-title": "h-[0px]",
};

// get 4 newest blog posts
const blogEntries = await getCollection("blog");

const newestBlogEntries = blogEntries
  .filter(post => post.slug !== entry.slug)
  .filter(post => !post.data.draft)
  .sort((a, b) => b.data.publishedOn.getTime() - a.data.publishedOn.getTime())
  .slice(0, 4);
---
{/*<script>
  // on scroll find the heading closest to the top of the screen, select the a that links to that heading and apply the data-selected attribute
  // important, do not ise an intersection observer
  const headings = document.querySelectorAll("h2, h3, h4, h5, h6");
  const toc = document.querySelector("#toc");

  // First, create an array from your NodeList
const headingsArray = Array.from(headings);

// Then, remove data-selected attribute from all the links
function clearSelected() {
  if (!toc) return;

  const tocLinks = toc.querySelectorAll('a');
  tocLinks.forEach(link => link.removeAttribute('data-selected'));
}

// Find the closest heading to the top of the screen
function findClosestHeading() {
  let closest = null;

  for (let i = 0; i < headingsArray.length; i++) {
    const heading = headingsArray[i];
    // Get the bounding client rect
    const rect = heading.getBoundingClientRect();

    // If the top of the heading is less than half the window height, but more than 0, it's the closest to the top
    if (rect.top > 0 && rect.top < window.innerHeight / 2) {
      closest = heading;
      break;
    }
  }

  return closest;
}

// On scroll, find the closest heading and select the corresponding link
window.addEventListener('scroll', () => {
  const closestHeading = findClosestHeading();

  if (closestHeading) {
    if (!toc) return;
    
    clearSelected();
    const id = closestHeading.getAttribute('id');
    const link = toc.querySelector(`a[href="#${id}"]`);
    if (link) {
      link.setAttribute('data-selected', 'true');
    }
  }
});

</script>*/}

<BaseLayout meta={{
  title: `${entry.data.title}â€”Simon Sorensen`,
  description: entry.data.excerpt,
  transitions: true,
  noIndex: entry.data.draft,
}}>

  <Navbar />

  {
    entry.data.cover && (
      <div class={`relative ${imageHeight[entry.data.coverLayout]} bg-zinc-800`}>
        <Image
          src={entry.data.cover}
          alt={entry.data.title}
          width={2000}
          quality="high"
          loading="eager"
          class="object-cover object-center w-full h-full"
        />
      </div>
    )
  }

  <div
    class="max-w-7xl mx-auto px-4 2xl:pl-[250px] pt-16 grid grid-cols-[1fr_250px] gap-8 relative h-fit"
  >
    <!-- Heading -->
    <div class="mb-8 col-span-2">
      <div class="flex items-center mb-8 gap-2">
        {entry.data.tags?.map((tag) => <Tag title={tag} />)}
      </div>

      <h1 class={`text-3xl md:text-4xl lg:text-5xl leading-normal md:leading-normal lg:leading-normal mb-2 font-serif font-light`}>
        {entry.data.title}
      </h1>
      <p class="text-zinc-400 text-xl">
        Published on <span class="text-zinc-200"
          >{
            entry.data.publishedOn.toLocaleDateString("en-GB", {
              year: "numeric",
              month: "long",
              day: "numeric",
            })
          }</span
        >
      </p>
    </div>

    <div class="text-lg prose prose-invert col-span-2 lg:col-span-1">
      <Content
        components={{
          h1: "h2",
          h2: "h3",
          h3: "h4",
          h4: "h5",
          h5: "h6",
          h6: "strong",
        }}
      />
    </div>

    <!-- Content -->
    <div class="sticky top-12 self-start hidden lg:block" id="toc">
      <h2 class="mb-3 text-zinc-300 font-bold">Table of Contents</h2>

      <TableOfContents headings={headings} />
    </div>

  </div>

  <div class="max-w-7xl px-4 my-12 md:mt-16 lg:mt-32 mx-auto">
    <h2 class="font-bold text-lg mb-4">Couple other blog posts</h2>

    <div class="flex gap-4 overflow-x-auto">
      {newestBlogEntries.map(entry => (
        <BlogPostCard post={entry} className="w-[250px]" />
      ))}
    </div>
  </div>

  <Footer />
</BaseLayout>
